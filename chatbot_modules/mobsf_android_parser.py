import os
import re
import json
import uuid
from typing import Dict, List, Any, Optional
from datetime import datetime
from pathlib import Path

# Import the PDF extractor for text extraction
try:
    from .pdf_extractor import extract_text_from_pdf
except ImportError:
    from pdf_extractor import extract_text_from_pdf

def parse_mobsf_report(raw_mobsf_text: str) -> Dict[str, Any]:
    """
    Parses raw MobSF report text into a structured dictionary.

    Args:
        raw_mobsf_text: The raw text content of a MobSF report.

    Returns:
        dict: A structured dictionary containing MobSF report information.
    """
# Standardize newlines for easier regex matching
    raw_mobsf_text = re.sub(r'\r\n', '\n', raw_mobsf_text)
    raw_mobsf_text = re.sub(r'\r', '\n', raw_mobsf_text)

    report = {
        "scan_metadata": {
            "tool": "Mobile Security Framework (MobSF)",
            "report_id": str(uuid.uuid4()),
            "scan_date": None,
            "mobsf_version": None,
            "app_security_score": None,
            "grade": None,
            "file_name": None,
            "package_name": None
        },
        "summary": {
            "findings_severity": {
                "High": 0,
                "Medium": 0,
                "Info": 0,
                "Secure": 0,
                "Hotspot": 0
            },
            "total_issues": 0
        },
        "file_information": {},
        "app_information": {},
        "app_components": {},
        "certificate_information": {},
        "application_permissions": [],
        "apkid_analysis": [],
        "network_security_findings": [],
        "certificate_analysis_findings": [],
        "manifest_analysis_findings": [],
        "code_analysis_findings": [],
        "niap_analysis": [],
        "abused_permissions_summary": {},
        "scan_logs": []
    }

    # --- Extract Scan Metadata and Summary ---
    file_name_match = re.search(r"File Name:\s*(.+?)\n", raw_mobsf_text)
    if file_name_match:
        report["scan_metadata"]["file_name"] = file_name_match.group(1).strip()
        report["file_information"]["File Name"] = file_name_match.group(1).strip()


    package_name_match = re.search(r"Package Name:\s*(.+?)\n", raw_mobsf_text)
    if package_name_match:
        report["scan_metadata"]["package_name"] = package_name_match.group(1).strip()
        report["app_information"]["Package Name"] = package_name_match.group(1).strip()


    scan_date_match = re.search(r"Scan Date:\s*(.+?)\n", raw_mobsf_text)
    if scan_date_match:
        # MobSF date format: April 19, 2025, 7:06 a.m.
        date_str = scan_date_match.group(1).strip().replace("a.m.", "AM").replace("p.m.", "PM")
        try:
            # Handle possible comma after year, and AM/PM conversion
            if ',' in date_str.split(',')[-1] and any(ext in date_str for ext in ["AM", "PM"]):
                 report["scan_metadata"]["scan_date"] = datetime.strptime(date_str, "%B %d, %Y, %I:%M %p").isoformat()
            else:
                report["scan_metadata"]["scan_date"] = date_str # Keep raw if parsing fails
        except ValueError:
            report["scan_metadata"]["scan_date"] = date_str # Keep raw if parsing fails


    app_score_match = re.search(r"App Security Score:\s*(\d+/\d+)\s*\((.+?)\)", raw_mobsf_text)
    if app_score_match:
        report["scan_metadata"]["app_security_score"] = app_score_match.group(1).strip()

    grade_match = re.search(r"Grade:\s*([A-E])", raw_mobsf_text)
    if grade_match:
        report["scan_metadata"]["grade"] = grade_match.group(1).strip()
    
    mobsf_version_match = re.search(r"Report Generated by - MobSF v(\d+\.\d+\.\d+)", raw_mobsf_text)
    if mobsf_version_match:
        report["scan_metadata"]["mobsf_version"] = mobsf_version_match.group(1).strip()


    # Findings Severity - Adjusted regex for double entries and numbers at the end
    severity_match = re.search(
        r"FINDINGS SEVERITY\s*.*?HIGH\s*.*?MEDIUM\s*.*?INFO\s*.*?SECURE\s*.*?HOTSPOT\s*\n\s*(\d+)\s*\n\s*(\d+)\s*\n\s*(\d+)\s*\n\s*(\d+)\s*\n\s*(\d+)",
        raw_mobsf_text,
        re.DOTALL
    )
    if severity_match:
        report["summary"]["findings_severity"]["High"] = int(severity_match.group(1))
        report["summary"]["findings_severity"]["Medium"] = int(severity_match.group(2))
        report["summary"]["findings_severity"]["Info"] = int(severity_match.group(3))
        report["summary"]["findings_severity"]["Secure"] = int(severity_match.group(4))
        report["summary"]["findings_severity"]["Hotspot"] = int(severity_match.group(5))
        report["summary"]["total_issues"] = sum(report["summary"]["findings_severity"].values())

    # --- File Information ---
    file_info_block = re.search(
        r"FILE INFORMATION\s*(.*?)(?=APP INFORMATION|APP COMPONENTS|CERTIFICATE INFORMATION|APPLICATION PERMISSIONS|\Z)",
        raw_mobsf_text,
        re.DOTALL
    )
    if file_info_block:
        info_text = file_info_block.group(1)
        # Assuming File Name is already populated by the global match,
        # otherwise, it would need a similar double-heading regex
        # file_name_local_match = re.search(r"File Name:\s*File Name:\s*(.+?)\n", info_text)
        # if file_name_local_match:
        #     report["file_information"]["File Name"] = file_name_local_match.group(1).strip()

        size_match = re.search(r"Size:\s*Size:\s*(.+?)\n", info_text)
        if size_match:
            report["file_information"]["Size"] = size_match.group(1).strip()
        md5_match = re.search(r"MD5:\s*MD5:\s*(.+?)\n", info_text)
        if md5_match:
            report["file_information"]["MD5"] = md5_match.group(1).strip()
        sha1_match = re.search(r"SHA1:\s*SHA1:\s*(.+?)\n", info_text)
        if sha1_match:
            report["file_information"]["SHA1"] = sha1_match.group(1).strip()
        sha256_match = re.search(r"SHA256:\s*SHA256:\s*(.+?)\n", info_text)
        if sha256_match:
            report["file_information"]["SHA256"] = sha256_match.group(1).strip()
        sha512_match = re.search(r"SHA512:\s*SHA512:\s*(.+?)\n", info_text)
        if sha512_match:
            report["file_information"]["SHA512"] = sha512_match.group(1).strip()
        sha384_match = re.search(r"SHA384:\s*SHA384:\s*(.+?)\n", info_text)
        if sha384_match:
            report["file_information"]["SHA384"] = sha384_match.group(1).strip()
        sha224_match = re.search(r"SHA224:\s*SHA224:\s*(.+?)\n", info_text)
        if sha224_match:
            report["file_information"]["SHA224"] = sha224_match.group(1).strip()
        sha128_match = re.search(r"SHA128:\s*SHA128:\s*(.+?)\n", info_text)
        if sha128_match:
            report["file_information"]["SHA128"] = sha128_match.group(1).strip()
        sha64_match = re.search(r"SHA64:\s*SHA64:\s*(.+?)\n", info_text)
        if sha64_match:
            report["file_information"]["SHA64"] = sha64_match.group(1).strip()

    # --- App Information ---
    app_info_block = re.search(
        r"APP INFORMATION\s*(.*?)(?=APP COMPONENTS|CERTIFICATE INFORMATION|APPLICATION PERMISSIONS|\Z)",
        raw_mobsf_text,
        re.DOTALL
    )
    if app_info_block:
        info_text = app_info_block.group(1)
        app_name_match = re.search(r"App Name:\s*(.+?)\n", info_text)
        if app_name_match:
            report["app_information"]["App Name"] = app_name_match.group(1).strip()
        main_activity_match = re.search(r"Main Activity:\s*(.+?)\n", info_text)
        if main_activity_match:
            report["app_information"]["Main Activity"] = main_activity_match.group(1).strip()
        target_sdk_match = re.search(r"Target SDK:\s*(\d+)\n", info_text)
        if target_sdk_match:
            report["app_information"]["Target SDK"] = int(target_sdk_match.group(1))
        min_sdk_match = re.search(r"Min SDK:\s*(\d+)\n", info_text)
        if min_sdk_match:
            report["app_information"]["Min SDK"] = int(min_sdk_match.group(1))
        max_sdk_match = re.search(r"Max SDK:\s*(.+?)\n", info_text)
        if max_sdk_match:
            # Max SDK can be empty or a number
            try:
                report["app_information"]["Max SDK"] = int(max_sdk_match.group(1).strip())
            except ValueError:
                report["app_information"]["Max SDK"] = max_sdk_match.group(1).strip() if max_sdk_match.group(1).strip() else None

        android_version_name_match = re.search(r"Android Version Name:\s*(.+?)\n", info_text)
        if android_version_name_match:
            report["app_information"]["Android Version Name"] = android_version_name_match.group(1).strip()
        android_version_code_match = re.search(r"Android Version Code:\s*(\d+)\n", info_text)
        if android_version_code_match:
            report["app_information"]["Android Version Code"] = int(android_version_code_match.group(1))

    # --- App Components ---
    app_components_block = re.search(
        r"APP COMPONENTS\s*(.*?)(?=CERTIFICATE INFORMATION|APPLICATION PERMISSIONS|\Z)",
        raw_mobsf_text,
        re.DOTALL
    )
    if app_components_block:
        info_text = app_components_block.group(1)
        components = [
            ("Activities", r"Activities:\s*(\d+)\n"),
            ("Services", r"Services:\s*(\d+)\n"),
            ("Receivers", r"Receivers:\s*(\d+)\n"),
            ("Providers", r"Providers:\s*(\d+)\n"),
            ("Exported Activities", r"Exported Activities:\s*(\d+)\n"),
            ("Exported Services", r"Exported Services:\s*(\d+)\n"),
            ("Exported Receivers", r"Exported Receivers:\s*(\d+)\n"),
            ("Exported Providers", r"Exported Providers:\s*(\d+)\n"),
        ]
        for name, pattern in components:
            match = re.search(pattern, info_text)
            if match:
                report["app_components"][name] = int(match.group(1))

    # --- Certificate Information ---
    cert_info_block = re.search(
        r"CERTIFICATE INFORMATION\s*(.*?)(?=APPLICATION PERMISSIONS|APKID ANALYSIS|\Z)",
        raw_mobsf_text,
        re.DOTALL
    )
    if cert_info_block:
        info_text = cert_info_block.group(1)
        report["certificate_information"]["Binary is signed"] = "Binary is signed" in info_text

        v1_match = re.search(r"v1 signature:\s*(True|False)", info_text)
        if v1_match:
            report["certificate_information"]["v1 signature"] = v1_match.group(1) == "True"
        v2_match = re.search(r"v2 signature:\s*(True|False)", info_text)
        if v2_match:
            report["certificate_information"]["v2 signature"] = v2_match.group(1) == "True"
        v3_match = re.search(r"v3 signature:\s*(True|False)", info_text)
        if v3_match:
            report["certificate_information"]["v3 signature"] = v3_match.group(1) == "True"
        v4_match = re.search(r"v4 signature:\s*(True|False)", info_text)
        if v4_match:
            report["certificate_information"]["v4 signature"] = v4_match.group(1) == "True"

        subject_match = re.search(r"X.509 Subject:\s*(.+?)\n", info_text)
        if subject_match:
            report["certificate_information"]["X.509 Subject"] = subject_match.group(1).strip()
        algo_match = re.search(r"Signature Algorithm:\s*(.+?)\n", info_text)
        if algo_match:
            report["certificate_information"]["Signature Algorithm"] = algo_match.group(1).strip()
        valid_from_match = re.search(r"Valid From:\s*(.+?)\n", info_text)
        if valid_from_match:
            report["certificate_information"]["Valid From"] = valid_from_match.group(1).strip()
        valid_to_match = re.search(r"Valid To:\s*(.+?)\n", info_text)
        if valid_to_match:
            report["certificate_information"]["Valid To"] = valid_to_match.group(1).strip()
        issuer_match = re.search(r"Issuer:\s*(.+?)\n", info_text)
        if issuer_match:
            report["certificate_information"]["Issuer"] = issuer_match.group(1).strip()
        serial_match = re.search(r"Serial Number:\s*(.+?)\n", info_text)
        if serial_match:
            report["certificate_information"]["Serial Number"] = serial_match.group(1).strip()
        hash_algo_match = re.search(r"Hash Algorithm:\s*(.+?)\n", info_text)
        if hash_algo_match:
            report["certificate_information"]["Hash Algorithm"] = hash_algo_match.group(1).strip()
        md5_cert_match = re.search(r"md5:\s*([0-9a-fA-F]+)\n", info_text)
        if md5_cert_match:
            report["certificate_information"]["md5_fingerprint"] = md5_cert_match.group(1).strip()
        sha1_cert_match = re.search(r"sha1:\s*([0-9a-fA-F]+)\n", info_text)
        if sha1_cert_match:
            report["certificate_information"]["sha1_fingerprint"] = sha1_cert_match.group(1).strip()
        sha256_cert_match = re.search(r"sha256:\s*([0-9a-fA-F]+)\n", info_text)
        if sha256_cert_match:
            report["certificate_information"]["sha256_fingerprint"] = sha256_cert_match.group(1).strip()
        sha512_cert_match = re.search(r"sha512:\s*([0-9a-fA-F]+)\n", info_text)
        if sha512_cert_match:
            report["certificate_information"]["sha512_fingerprint"] = sha512_cert_match.group(1).strip()
        public_key_algo_match = re.search(r"PublicKey Algorithm:\s*(.+?)\n", info_text)
        if public_key_algo_match:
            report["certificate_information"]["PublicKey Algorithm"] = public_key_algo_match.group(1).strip()
        bit_size_match = re.search(r"Bit Size:\s*(\d+)\n", info_text)
        if bit_size_match:
            report["certificate_information"]["Bit Size"] = int(bit_size_match.group(1))
        fingerprint_match = re.search(r"Fingerprint:\s*([0-9a-fA-F]+)\n", info_text)
        if fingerprint_match:
            report["certificate_information"]["Fingerprint"] = fingerprint_match.group(1).strip()
        unique_certs_match = re.search(r"Found (\d+) unique certificates", info_text)
        if unique_certs_match:
            report["certificate_information"]["Found Unique Certificates"] = int(unique_certs_match.group(1))

    # --- Application Permissions ---
    # Adjusted permissions_block regex to account for duplicated headings
    permissions_block = re.search(
        r"APPLICATION PERMISSIONS\s*PERMISSION\s*PERMISSION\s*STATUS\s*STATUS\s*INFO\s*INFO\s*DESCRIPTION\s*DESCRIPTION\s*(.*?)(?=APKID ANALYSIS|NETWORK SECURITY|\Z)",
        raw_mobsf_text,
        re.DOTALL
    )
    if permissions_block:
        permissions_text = permissions_block.group(1).strip()
        # Regex to capture each permission entry
        # Capture permission name, status, and then the entire remaining block for info/description
        permission_pattern = re.compile(
            r"^(android\.permission\.[^\n]+)\n"  # Group 1: Permission name
            r"\s*(dangerous|normal)\n"           # Group 2: Status (with optional leading whitespace)
            r"(.*?)(?=(?:\nandroid\.permission\.)|\Z)", # Group 3: The rest of the block (info + description), non-greedy
            re.DOTALL | re.MULTILINE
        )
        for match in permission_pattern.finditer(permissions_text):
            permission_name = match.group(1).strip()
            status = match.group(2).strip()
            remaining_text_block = match.group(3).strip()

            info = ""
            description = ""

            # Attempt to split remaining_text_block into info and description
            # The description often starts with "Allows an application to"
            description_start_match = re.search(r"Allows an application to", remaining_text_block, re.DOTALL)

            if description_start_match:
                # Everything before "Allows an application to" is info
                info = remaining_text_block[:description_start_match.start()].strip()
                # Everything from "Allows an application to" is description
                description = remaining_text_block[description_start_match.start():].strip()
            else:
                # If "Allows an application to" is not found, treat the whole thing as info for now
                info = remaining_text_block

            # Clean up whitespace and newlines in info and description
            info = re.sub(r'\s+', ' ', info).strip()
            description = re.sub(r'\s+', ' ', description).strip()

            report["application_permissions"].append({
                "permission": permission_name,
                "status": status,
                "info": info,
                "description": description
            })

# --- APKID Analysis ---
    # Adjusted apkid_block regex to account for duplicated headings and ensure it captures the correct content block
    apkid_block = re.search(
        r"APKID ANALYSIS\s*FILE\s*FILE\s*DETAILS\s*DETAILS\s*classes\.dex\s*FINDINGS\s*FINDINGS\s*DETAILS\s*DETAILS\s*(.*?)(?=NETWORK SECURITY|\Z)",
        raw_mobsf_text,
        re.DOTALL
    )
    if apkid_block:
        apkid_text = apkid_block.group(1).strip()
        # Regex to capture each finding, assuming finding name is on one line and details on the next
        apkid_pattern = re.compile(
            r"^(.*?)\n(.*?)(?=\n[^\n]|\Z)", # Group 1: finding (non-greedy), Group 2: details (non-greedy) until next non-empty line or end
            re.DOTALL | re.MULTILINE
        )
        for match in apkid_pattern.finditer(apkid_text):
            finding_name = match.group(1).strip()
            finding_details = match.group(2).strip()
            
            report["apkid_analysis"].append({
                "finding": finding_name,
                "details": finding_details
            })


# --- Network Security (NO SCOPE SEVERITY DESCRIPTION block) ---
    # Adjusted regex to account for duplicated headings
    network_security_block = re.search(
        r"NETWORK SECURITY\s*NO\s*NO\s*SCOPE\s*SCOPE\s*SEVERITY\s*SEVERITY\s*DESCRIPTION\s*DESCRIPTION\s*(.*?)(?=CERTIFICATE ANALYSIS|\Z)",
        raw_mobsf_text,
        re.DOTALL
    )
    if network_security_block:
        # Currently, the example text for Network Security is empty under this header.
        # If there were entries, we'd parse them similarly to other table-like structures.
        pass # No content to parse in the example for this section

# --- Certificate Analysis ---
    cert_analysis_block = re.search(
        r"CERTIFICATE ANALYSIS\s*HIGH:\s*\d+\s*(\d+)\s*\|\s*WARNING:\s*\d+\s*(\d+)\s*\|\s*INFO:\s*\d+\s*(\d+)\s*(?:\|\s*SECURE:\s*(\d+))?\s*\n*TITLE\s*TITLE\s*SEVERITY\s*SEVERITY\s*DESCRIPTION\s*DESCRIPTION\s*(.*?)(?=MANIFEST ANALYSIS|\Z)",
        raw_mobsf_text,
        re.DOTALL
    )
    if cert_analysis_block:
        # Extract counts (the second number in the duplicated pair)
        # high_count = int(cert_analysis_block.group(1))
        # warning_count = int(cert_analysis_block.group(2))
        # info_count = int(cert_analysis_block.group(3))
        # secure_count = int(cert_analysis_block.group(4)) if cert_analysis_block.group(4) else 0

        # The actual findings text is in group 5 after adjusting for new captures and duplicated headers
        findings_text = cert_analysis_block.group(5).strip()
        
        # Regex to capture each finding: Title (can be multi-line), Severity, Description (can be multi-line)
        cert_finding_pattern = re.compile(
            # Group 1: Title (matches any character, including newlines, non-greedily, until the severity line)
            r"(.*?)\n"
            # Group 2: Severity (must be info, warning, or high, on its own line after optional whitespace)
            r"\s*(info|warning|high)\s*\n"
            # Group 3: Description (matches any character, including newlines, non-greedily, until the lookahead)
            r"\s*(.+?)"
            # Lookahead: Matches either the start of a new finding (a title followed by a severity line) or the end of the string
            r"(?=\n(?:.+?)\n\s*(?:info|warning|high)\s*\n|\Z)",
            re.DOTALL # Allows '.' to match newlines
            # re.MULTILINE is not used here as we want '^' and '$' behavior to apply to the entire findings_text block,
            # not individual lines within it, when parsing with finditer.
        )
        for match in cert_finding_pattern.finditer(findings_text):
            report["certificate_analysis_findings"].append({
                "title": re.sub(r'\s+', ' ', match.group(1)).strip(), # Clean up whitespace in title
                "severity": match.group(2).strip(),
                "description": re.sub(r'\s+', ' ', match.group(3)).strip() # Clean up whitespace in description
            })

# --- Manifest Analysis ---
    # Adjusted manifest_analysis_block regex to account for duplicated counts and duplicated headers
    manifest_analysis_block = re.search(
        r"MANIFEST ANALYSIS\s*HIGH:\s*\d+\s*(\d+)\s*\|\s*WARNING:\s*\d+\s*(\d+)\s*\|\s*INFO:\s*\d+\s*(\d+)\s*\|\s*SUPPRESSED:\s*\d+\s*(\d+)\s*\n*NO\s*NO\s*ISSUE\s*ISSUE\s*SEVERITY\s*SEVERITY\s*DESCRIPTION\s*DESCRIPTION\s*(.*?)(?=CODE ANALYSIS|\Z)",
        raw_mobsf_text,
        re.DOTALL
    )
    if manifest_analysis_block:
        # The first four capturing groups are the counts (second number in the duplicated pair)
        # high_count = int(manifest_analysis_block.group(1))
        # warning_count = int(manifest_analysis_block.group(2))
        # info_count = int(manifest_analysis_block.group(3))
        # suppressed_count = int(manifest_analysis_block.group(4))

        # The actual findings text is in group 5
        findings_text = manifest_analysis_block.group(5).strip()
        
        # Regex to capture each finding: Number, Issue (multi-line), Severity, Description (multi-line)
        manifest_finding_pattern = re.compile(
            # Group 1: Number (one or more digits)
            r"(\d+)\s*\n*"
            # Group 2: Issue (matches any character including newlines, non-greedily, until the severity line)
            r"(.+?)"
            # Group 3: Severity (high|warning|info|suppressed, on its own line after optional whitespace)
            r"\s*\n\s*(high|warning|info|suppressed)\s*\n"
            # Group 4: Description (matches any character including newlines, non-greedily)
            r"\s*(.+?)"
            # Lookahead: Matches either the start of a new finding (a number on a new line after optional whitespace)
            # or the end of the string. This ensures the description captures everything until the next finding.
            r"(?=\n\d+\s*\n|\Z)",
            re.DOTALL # Allows '.' to match newlines
            # re.MULTILINE is not used here as we are applying this pattern to the entire findings_text block.
        )
        for match in manifest_finding_pattern.finditer(findings_text):
            report["manifest_analysis_findings"].append({
                "number": int(match.group(1)),
                "issue": re.sub(r'\s+', ' ', match.group(2)).strip(), # Clean up whitespace in issue
                "severity": match.group(3).strip(),
                "description": re.sub(r'\s+', ' ', match.group(4)).strip() # Clean up whitespace in description
            })

# --- Code Analysis ---
    # Adjusted code_analysis_block regex to account for duplicated counts and duplicated headers
    code_analysis_block = re.search(
        r"CODE ANALYSIS\s*HIGH:\s*\d+\s*(\d+)\s*\|\s*WARNING:\s*\d+\s*(\d+)\s*\|\s*INFO:\s*\d+\s*(\d+)\s*\|\s*SECURE:\s*\d+\s*(\d+)\s*\|\s*SUPPRESSED:\s*\d+\s*(\d+)\s*\n*NO\s*NO\s*ISSUE\s*ISSUE\s*SEVERITY\s*SEVERITY\s*STANDARDS\s*STANDARDS\s*FILES\s*FILES\s*(.*?)(?=NIAP ANALYSIS|\Z)",
        raw_mobsf_text,
        re.DOTALL
    )
    if code_analysis_block:
        # The first five capturing groups are the counts (second number in the duplicated pair)
        # high_count = int(code_analysis_block.group(1))
        # warning_count = int(code_analysis_block.group(2))
        # info_count = int(code_analysis_block.group(3))
        # secure_count = int(code_analysis_block.group(4))
        # suppressed_count = int(code_analysis_block.group(5))

        # The actual findings text is in group 6
        findings_text = code_analysis_block.group(6).strip()
        
        # Regex to capture each finding: Number, Issue (multi-line), Severity, Standards (multi-line), Files (multi-line)
        code_finding_pattern = re.compile(
            # Group 1: Number (one or more digits)
            r"(\d+)\s*\n*"
            # Group 2: Issue (matches any character including newlines, non-greedily, until the severity line)
            r"(.+?)(?=\n\s*(?:high|warning|info|secure|suppressed)\s*\n)"
            # Group 3: Severity (high|warning|info|secure|suppressed, on its own line after optional whitespace)
            r"\s*\n\s*(high|warning|info|secure|suppressed)\s*\n"
            # Group 4: Standards (matches any character including newlines, non-greedily, until the file line or end)
            r"(.+?)(?=\n\s*[a-zA-Z0-9_/]+\.(?:java|kt|class)\s*|\Z)" # Lookahead for file path line or end of string
            # Group 5: Files (matches any character including newlines, non-greedily, until the start of the next numbered finding or end of string)
            r"\s*(.+?)"
            # Lookahead: Matches either the start of a new finding (a number on a new line after optional whitespace)
            # or the end of the string. This ensures the files capture everything until the next finding.
            r"(?=\n\d+\s*\n|\Z)",
            re.DOTALL # Allows '.' to match newlines
            # re.MULTILINE is not used here as we are applying this pattern to the entire findings_text block.
        )
        for match in code_finding_pattern.finditer(findings_text):
            report["code_analysis_findings"].append({
                "number": int(match.group(1)),
                "issue": re.sub(r'\s+', ' ', match.group(2)).strip(), # Clean up whitespace in issue
                "severity": match.group(3).strip(),
                "standards": re.sub(r'\s+', ' ', match.group(4)).strip(), # Clean up whitespace in standards
                "files": re.sub(r'\s+', ' ', match.group(5)).strip() # Clean up whitespace in files
            })

# --- NIAP Analysis ---
    # Adjusted niap_analysis_block regex to account for duplicated headings
    niap_analysis_block = re.search(
        r"NIAP ANALYSIS v(\d+\.\d+)\s*NO\s*NO\s*IDENTIFIER\s*IDENTIFIER\s*REQUIREMENT\s*REQUIREMENT\s*FEATURE\s*FEATURE\s*DESCRIPTION\s*DESCRIPTION\s*(.*?)(?=ABUSED PERMISSIONS SUMMARY|\Z)",
        raw_mobsf_text,
        re.DOTALL
    )
    if niap_analysis_block:
        # niap_version = niap_analysis_block.group(1) # Unused for now
        niap_findings_text = niap_analysis_block.group(2).strip()
        # The provided sample text does not contain actual NIAP findings under this header.
        # If there were entries, we'd parse them similarly to other table-like structures.
        pass # No content to parse in the example for this section

# --- Abused Permissions Summary ---
    # Adjusted abused_permissions_block regex to account for the leading special character and duplicated headings
    abused_permissions_block = re.search(
        r"\s*\s*ABUSED PERMISSIONS\s*TYPE\s*TYPE\s*MATCHES\s*MATCHES\s*PERMISSIONS\s*PERMISSIONS\s*(.*?)(?=SCAN LOGS|\Z)",
        raw_mobsf_text,
        re.DOTALL
    )
    if abused_permissions_block:
        abused_permissions_text = abused_permissions_block.group(1).strip()
        abused_permissions_summary = {}

        # Regex to capture each permission type, matches count, and permissions list.
        # Adjusted to handle multi-line input for these fields.
        permission_type_pattern = re.compile(
            r"^(.*?)\n" +           # Group 1: Type (non-greedy, up to the first newline)
            r"\s*(\d+/\d+)\n" +      # Group 2: Matches (on its own line after optional whitespace)
            r"\s*([^\n]*)",          # Group 3: Permissions (on its own line after optional whitespace, allowing empty string)
            re.MULTILINE             # Allows '^' and '$' to match start/end of lines
        )

        for match in permission_type_pattern.finditer(abused_permissions_text):
            p_type = match.group(1).strip()
            matches = match.group(2).strip()
            permissions_str = match.group(3).strip()
            permissions = [p.strip() for p in permissions_str.split(',') if p.strip()] # Split and filter empty strings
            
            abused_permissions_summary[p_type] = {
                "matches": matches,
                "permissions": permissions
            }
        
        # Add descriptions if they exist after the main table
        # This pattern seems to still be correct for the description format
        description_pattern = re.compile(
            r"^(.*?):\s*(.+)",
            re.MULTILINE
        )
        # Apply description parsing only to the part of abused_permissions_text that contains descriptions
        # This assumes descriptions are at the end of the block and not interleaved
        # A simple approach for now is to run it on the whole block as it handles non-matching lines gracefully.
        
        for match in description_pattern.finditer(abused_permissions_text):
            p_type_desc = match.group(1).strip()
            description = match.group(2).strip()
            if p_type_desc in abused_permissions_summary:
                abused_permissions_summary[p_type_desc]["description"] = description
            # Handle the case where the key might not directly match (e.g., if there's a slight difference in naming)
            # For this example, it seems to match directly.
        
        report["abused_permissions_summary"] = abused_permissions_summary


# --- Scan Logs ---
    # Adjusted scan_logs_block regex to account for the leading special character and duplicated headings
    scan_logs_block = re.search(
        r"\s*\s*SCAN LOGS\s*Timestamp\s*Timestamp\s*Event\s*Event\s*Error\s*Error\s*(.*?)(?=\Z)", # Ends at end of text
        raw_mobsf_text,
        re.DOTALL
    )
    if scan_logs_block:
        scan_logs_text = scan_logs_block.group(1).strip()
        # Regex to capture each log entry: Timestamp, Event, Error.
        # This pattern assumes each log entry is on a single line.
        scan_log_pattern = re.compile(
            r"^(.*?)\s+(.*?)\s+(.*?)$", # Group 1: Timestamp, Group 2: Event, Group 3: Error
            re.MULTILINE # Allows '^' and '$' to match start/end of lines within scan_logs_text
        )
        for match in scan_log_pattern.finditer(scan_logs_text):
            report["scan_logs"].append({
                "timestamp": match.group(1).strip(),
                "event": match.group(2).strip(),
                "error": match.group(3).strip()
            })

    return report

def process_mobsf_android_report_file(pdf_path: str) -> Dict[str, Any]:
    """
    Processes a MobSF Android report PDF file and returns structured data.

    Args:
        pdf_path: Path to the MobSF Android report PDF file.

    Returns:
        dict: Structured MobSF report data.
    """
    if not os.path.exists(pdf_path):
        raise FileNotFoundError(f"MobSF report not found: {pdf_path}")

    print(f"Processing MobSF report: {pdf_path}")

    # Extract text from PDF
    try:
        raw_text = extract_text_from_pdf(pdf_path)
        if not raw_text.strip():
            raise ValueError("Extracted text is empty or contains only whitespace.")

        # Parse the MobSF report
        report_data = parse_mobsf_report(raw_text)

        # Add file metadata
        report_data["file_metadata"] = {
            "filename": os.path.basename(pdf_path),
            "file_size": os.path.getsize(pdf_path),
            "last_modified": datetime.fromtimestamp(os.path.getmtime(pdf_path)).isoformat()
        }

        return report_data

    except Exception as e:
        print(f"Error processing MobSF report {pdf_path}: {str(e)}")
        raise

if __name__ == "__main__":
    import sys
    
    # This check needs to be adjusted for the environment it runs in.
    # In a typical script, you'd ensure pdf_extractor is available.
    # Here, we'll ensure a dummy is created if it's missing for standalone execution.
    if not os.path.exists("pdf_extractor.py"):
        with open("pdf_extractor.py", "w") as f:
            f.write("""
import PyPDF2
import os

def extract_text_from_pdf(pdf_path: str) -> str:
    if not os.path.exists(pdf_path):
        raise FileNotFoundError(f"The PDF file was not found: {pdf_path}")
    extracted_text = ""
    try:
        with open(pdf_path, 'rb') as file:
            reader = PyPDF2.PdfReader(file)
            for page_num in range(len(reader.pages)):
                page = reader.pages[page_num]
                text = page.extract_text()
                if text:
                    extracted_text += text + "\\n"
    except PyPDF2.errors.PdfReadError as e:
        raise PyPDF2.errors.PdfReadError(f"Error reading PDF file {pdf_path}: {e}. It might be corrupted or encrypted.")
    except Exception as e:
        raise Exception(f"Error extracting text from PDF {pdf_path}: {e}")
    return extracted_text

if __name__ == "__main__":
    # Dummy usage for pdf_extractor.py
    print("This is a dummy pdf_extractor.py. It requires an actual PDF file and 'pypdf' library to function fully.")
""")
        print("Created a dummy 'pdf_extractor.py'. Please ensure 'pypdf' is installed (`pip install pypdf`).")


    # Example usage with dummy text
    dummy_mobsf_text = """
ANDROID STATIC ANALYSIS REPORT


 
 
BitbarSampleApp 
BitbarSampleApp 
(1.0)
(1.0)

File Name:
bitbar-sample-app.apk
Package Name:
com.bitbar.testdroid
Scan Date:
April 19, 2025, 7:06 a.m.
App Security Score:
32/100 (HIGH RISK)
Grade:
C


 FINDINGS SEVERITY

 HIGH
 HIGH

 MEDIUM
 MEDIUM

 INFO
 INFO

 SECURE
 SECURE


 HOTSPOT
 HOTSPOT
5
4
0
1
1

 FILE INFORMATION
File Name:
File Name:
 bitbar-sample-app.apk
Size:
Size:
0.11MB
MD5:
MD5:
 00cc5435151aa38a091781922c0390a4
SHA1:
SHA1:
 40e991508120d6f5d653a6755d8209df4d20289d
SHA256:
SHA256:
 3b4d462b8cce5f377a33417e1be7680717065f280a9f6e2f6af49325dbe89411

 APP INFORMATION
App Name:
App Name:
 BitbarSampleApp
Package Name:
Package Name:
 com.bitbar.testdroid
Main Activity:
Main Activity:
 com.bitbar.testdroid.BitbarSampleApplicationActivity
Target SDK:
Target SDK:
 33
Min SDK:
Min SDK:
 4
Max SDK:
Max SDK:

Android Version Name:
Android Version Name:
 1.0
Android Version Code:
Android Version Code:
 1

 APP COMPONENTS
Activities:
Activities:
 3
Services:
Services:
 0
Receivers:
Receivers:
 0
Providers:
Providers:
 0
Exported Activities:
Exported Activities:

2
Exported Services:
Exported Services:

0
Exported Receivers:
Exported Receivers:

0
Exported Providers:
Exported Providers:

0

 CERTIFICATE INFORMATION
Binary is signed
v1 signature: True
v2 signature: True
v3 signature: False
v4 signature: False
X.509 Subject: CN=Android Debug, O=Android, C=US
Signature Algorithm: rsassa_pkcs1v15
Valid From: 2022-07-05 09:35:34+00:00
Valid To: 2052-06-27 09:35:34+00:00
Issuer: CN=Android Debug, O=Android, C=US
Serial Number: 0x1
Hash Algorithm: sha1
md5: f5e77c7ea1c2102188be9eae9a3b8573
sha1: a7ce1335a1bbb135d34c208b51945cc93104c7ed
sha256: 93424fddcac08ed772ccaf7a20cd2cda4fc83f101656536154ef92846c2f3ffc
sha512: ec768feee2bcc63bdd65c642767b717a8cf0b855772497c302a4e0109c44f544a40338e9164be8053011f575a7e0a6196e08e9cca78a1589510a0820e4b4bd93
PublicKey Algorithm: rsa
Bit Size: 2048
Fingerprint: ff557fc6f6139b576a27f7f3cb4efe09a12090029a11ab150eaddf7c79d6ec67
Found 1 unique certificates

 APPLICATION PERMISSIONS
PERMISSION
PERMISSION
STATUS
STATUS
INFO
INFO
DESCRIPTION
DESCRIPTION
android.permission.WRITE_EXTERNAL_STORAGE
dangerous
read/modify/delete external storage
contents
Allows an application to write to external
storage.
android.permission.INTERNET
normal
full Internet access
Allows an application to create network sockets.

 APKID ANALYSIS
FILE
FILE
DETAILS
DETAILS
classes.dex
FINDINGS
FINDINGS
DETAILS
DETAILS
Compiler
r8 without marker (suspicious)

 NETWORK SECURITY
NO
NO
SCOPE
SCOPE
SEVERITY
SEVERITY
DESCRIPTION
DESCRIPTION

 CERTIFICATE ANALYSIS
HIGH:
2
2
 |
WARNING:
1
1
 |
INFO:
1
1

TITLE
TITLE
SEVERITY
SEVERITY
DESCRIPTION
DESCRIPTION
Signed Application
info
Application is signed with a code signing certificate
Application vulnerable
to Janus Vulnerability
warning
Application is signed with v1 signature scheme, making it vulnerable to Janus vulnerability on Android 5.0-8.0, if signed
only with v1 signature scheme. Applications running on Android 5.0-7.0 signed with v1, and v2/v3 scheme is also
vulnerable.
Application signed with
debug certificate
high
Application signed with a debug certificate. Production application must not be shipped with a debug certificate.
Certificate algorithm
vulnerable to hash
collision
high
Application is signed with SHA1withRSA. SHA1 hash algorithm is known to have collision issues.      

 MANIFEST ANALYSIS
HIGH:
2
2
 |
WARNING:
3
3
 |
INFO:
0
0
 |
SUPPRESSED:
0
0

NO
NO
ISSUE
ISSUE
SEVERITY
SEVERITY
DESCRIPTION
DESCRIPTION
1
App can be installed on a vulnerable
upatched Android version
Android 1.6, [minSdk=4]
high
This application can be installed on an older version of android that has multiple unfixed
vulnerabilities. These devices won't receive reasonable security updates from Google.
Support an Android version => 10, API 29 to receive reasonable security updates.
2
Debug Enabled For App
[android:debuggable=true]
high
Debugging was enabled on the app which makes it easier for reverse engineers to hook a
debugger to it. This allows dumping a stack trace and accessing debugging helper classes.
3
Application Data can be Backed up
[android:allowBackup] flag is missing.
warning
The flag [android:allowBackup] should be set to false. By default it is set to true and allows      
anyone to backup your application data via adb. It allows users who have enabled USB
debugging to copy application data off of the device.
4
Activity
(com.bitbar.testdroid.CorrectAnswerActivity)
is not Protected.
[android:exported=true]
warning
An Activity is found to be shared with other apps on the device therefore leaving it
accessible to any other application on the device.
5
Activity
(com.bitbar.testdroid.WrongAnswerActivity)
is not Protected.
[android:exported=true]
warning
An Activity is found to be shared with other apps on the device therefore leaving it
accessible to any other application on the device.
NO
NO
ISSUE
ISSUE
SEVERITY
SEVERITY
DESCRIPTION
DESCRIPTION

 CODE ANALYSIS
HIGH:
1
1
 |
WARNING:
0
0
 |
INFO:
0
0
 |
SECURE:
0
0
 |
SUPPRESSED:
0
0

NO
NO
ISSUE
ISSUE
SEVERITY
SEVERITY
STANDARDS
STANDARDS
FILES
FILES
1
Debug configuration enabled.
Production builds must not be
debuggable.
high
CWE:
CWE-919: Weaknesses in Mobile Applications
OWASP Top 10:
M1: Improper Platform Usage
OWASP MASVS:
MSTG-RESILIENCE-2
com/bitbar/testdroid/BuildConfig.java

 NIAP ANALYSIS v1.3
NO
NO
IDENTIFIER
IDENTIFIER
REQUIREMENT
REQUIREMENT
FEATURE
FEATURE
DESCRIPTION
DESCRIPTION

 ABUSED PERMISSIONS
TYPE
TYPE
MATCHES
MATCHES
PERMISSIONS
PERMISSIONS
Malware Permissions
2/25
android.permission.WRITE_EXTERNAL_STORAGE, android.permission.INTERNET
Other Common Permissions
0/44
Malware Permissions:
Top permissions that are widely abused by known malware.
Other Common Permissions:
Permissions that are commonly abused by known malware.

 SCAN LOGS
Timestamp
Timestamp
Event
Event
Error
Error
2025-04-19 07:06:19
Generating Hashes
OK
2025-04-19 07:06:19
Extracting APK
OK
2025-04-19 07:06:19
Unzipping
OK
2025-04-19 07:06:19
Parsing APK with androguard
OK
2025-04-19 07:06:19
Extracting APK features using aapt/aapt2
OK
2025-04-19 07:06:19
Getting Hardcoded Certificates/Keystores
OK
2025-04-19 07:06:20
Parsing AndroidManifest.xml
OK
2025-04-19 07:06:20
Extracting Manifest Data
OK
2025-04-19 07:06:20
Manifest Analysis Started
OK
2025-04-19 07:06:20
Performing Static Analysis on: BitbarSampleApp (com.bitbar.testdroid)
OK
2025-04-19 07:06:20
Fetching Details from Play Store: com.bitbar.testdroid
OK
2025-04-19 07:06:20
Checking for Malware Permissions
OK
2025-04-19 07:06:20
Fetching icon path
OK
2025-04-19 07:06:20
Library Binary Analysis Started
OK
2025-04-19 07:06:20
Reading Code Signing Certificate
OK
2025-04-19 07:06:20
Running APKiD 2.1.5
OK
2025-04-19 07:06:22
Detecting Trackers
OK
2025-04-19 07:06:22
Decompiling APK to Java with JADX
OK
2025-04-19 07:06:23
Converting DEX to Smali
OK
2025-04-19 07:06:23
Code Analysis Started on - java_source
OK
2025-04-19 07:06:23
Android SBOM Analysis Completed
OK
2025-04-19 07:06:23
Android SAST Completed
OK
2025-04-19 07:06:23
Android API Analysis Started
OK
2025-04-19 07:06:23
Android API Analysis Completed
OK
2025-04-19 07:06:23
Android Permission Mapping Started
OK
2025-04-19 07:06:23
Android Permission Mapping Completed
OK
2025-04-19 07:06:23
Android Behaviour Analysis Started
OK
2025-04-19 07:06:24
Android Behaviour Analysis Completed
OK
2025-04-19 07:06:24
Extracting Emails and URLs from Source Code
OK
2025-04-19 07:06:24
Email and URL Extraction Completed
OK
2025-04-19 07:06:24
Extracting String data from APK
OK
2025-04-19 07:06:24
Extracting String data from Code
OK
2025-04-19 07:06:24
Extracting String values and entropies from Code
OK
2025-04-19 07:06:24
Performing Malware check on extracted domains
OK
2025-04-19 07:06:24
Saving to Database
OK
Report Generated by - MobSF v4.3.1
Mobile Security Framework (MobSF) is an automated, all-in-one mobile application (Android/iOS/Windows) pen-testing, malware analysis and security assessment
framework capable of performing static and dynamic analysis.
© 2025 Mobile Security Framework - MobSF |
Ajin Abraham
 |
OpenSecurity
.
    """
    
    print("\n--- Testing MobSF Parser with Dummy Text ---")
    try:
        parsed_mobsf_report = parse_mobsf_report(dummy_mobsf_text)
        print("Successfully parsed dummy MobSF report.")
        # print(json.dumps(parsed_mobsf_report, indent=2)) # Uncomment to see full JSON output

        # Verify some extracted data
        print(f"App Name: {parsed_mobsf_report['app_information']['App Name']}")
        print(f"Scan Date: {parsed_mobsf_report['scan_metadata']['scan_date']}")
        print(f"High Severity Findings: {parsed_mobsf_report['summary']['findings_severity']['High']}")
        print(f"Total Manifest Analysis Findings: {len(parsed_mobsf_report['manifest_analysis_findings'])}")
        print(f"First Manifest Issue Description: {parsed_mobsf_report['manifest_analysis_findings'][0]['description']}")
        print(f"First Certificate Analysis Finding Title: {parsed_mobsf_report['certificate_analysis_findings'][0]['title']}")
        print(f"First Code Analysis Finding Issue: {parsed_mobsf_report['code_analysis_findings'][0]['issue']}")
        print(f"Malware Permissions Description: {parsed_mobsf_report['abused_permissions_summary']['Malware Permissions Description']}")
        
        # Save dummy parsed output to a JSON file
        output_path = "mobsf_report_parsed_dummy.json"
        with open(output_path, 'w') as f:
            json.dump(parsed_mobsf_report, f, indent=2)
        print(f"Dummy parsed output saved to: {output_path}")

    except Exception as e:
        print(f"Error parsing dummy MobSF report: {str(e)}")

    if len(sys.argv) > 1:
        report_path = sys.argv[1]
        try:
            report = process_mobsf_report_file(report_path)
            print(f"Successfully processed MobSF report: {report_path}")
            print(f"App Name: {report['app_information'].get('App Name', 'N/A')}")
            print(f"App Security Score: {report['scan_metadata'].get('app_security_score', 'N/A')}")
            print(f"Total findings: {report['summary']['total_issues']}")

            # Save structured output to a JSON file
            output_path = os.path.splitext(report_path)[0] + "_parsed.json"
            with open(output_path, 'w') as f:
                json.dump(report, f, indent=2)
            print(f"Structured output saved to: {output_path}")

        except Exception as e:
            print(f"Error: {str(e)}")
            sys.exit(1)
    else:
        print("\nUsage: python your_script_name.py <path_to_mobsf_report.pdf>")
        print("Or run without arguments to test with dummy text.")